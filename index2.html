<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://fonts.googleapis.com/css2?family=Oswald&display=swap" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="style.css">
        <link rel="shortcut icon" href="logo.png"/>
        <title>TaskUp</title>
        <style></style>
    </head>
    <body>
        <h1>TaskUp</h1>
      
        <h2>Add Task:</h2>

        <div id="addTaskForm">
          <form>
            <div class="task">
              <input type="text" id="taskName" placeholder="Task Name">
              <input type="text" id="taskDuration" placeholder="Duration">
              <!-- adding duration -->
              <select id="durationUnit">
                  <option value="minutes">Minutes</option>
                  <option value="hours">Hours</option>
              </select>
              <!-- adding the task dependency -->
              <select id="taskDependency">
                  <option value="">Dependency</option>
              </select>            
            </div>
          </form>
          <button class="button button1" onclick="addTask()">Add</button>
        </div>

        <h2>Tasks:</h2>
        <div id="addTaskForm">
          <form>
            <!-- task container-->
            <div id="taskContainer">
              
            </div>

            <!-- sorted task will appear here -->
            <div id="sortedtaskContainer"></div>
          </form>
        </div>

        <!-- choose first & last task-->
        <h2>Task Order</h2>
        
        <div id="addTaskForm">
          <form>
            <div>
              <label for="firstTask">First Task:</label>
              <select id="firstTask"></select>
            </div>
            <div>
              <label for="endTask">End Task:</label>
              <select id="endTask"></select>
            </div>
          </form>
          <button class="button button2" onclick="sortTasks()">Sort Tasks</button>
        </div>

        <!--path-->
        <h2>Sorted Tasks:</h2>

        <div id="addTaskForm">
          <form>
            <div id="sortedTasksContainer"></div>
          </form>
        </div>

        <div>

        </div>
        <!-- total duration-->
        <div id="totalTime">
          <form>
            <h3>Total Duration:
                <span id="totalDuration"></span>
            </h3>
          </form>
        </div>

        <div></div>

        <script>
  // Place your JavaScript code here
  // STORE THE TASKS
  let tasks = [];



  // add task function
  function addTask() {
    const taskName = document.getElementById("taskName").value;
    let taskDuration = document.getElementById("taskDuration").value;
    const durationUnit = document.getElementById("durationUnit").value;
    const taskDependency = document.getElementById("taskDependency").value;

    let task = {
      name: taskName,
      duration: taskDuration,
      durationUnit: durationUnit,
      dependency: taskDependency,
    };

    tasks.push(task);
    console.log(tasks)
    updateDependencyDropdown();
    renderTasks(tasks, "taskContainer");


  }

  function updateDependencyDropdown() {
    const taskDependencyDropdown = document.getElementById("taskDependency");

    const firstTaskDropdown = document.getElementById("firstTask");
    const endTaskDropdown = document.getElementById("endTask");

    // Clear existing options
    taskDependencyDropdown.innerHTML = "";
    firstTaskDropdown.innerHTML = "";
    endTaskDropdown.innerHTML = "";

    // Add new options
    const noDependencyOption = document.createElement("option");
    noDependencyOption.value = "";
    noDependencyOption.textContent = "Dependency";
    taskDependencyDropdown.appendChild(noDependencyOption);

    tasks.forEach(function (task) {
      let option = document.createElement("option");
      option.value = task.name;
      option.textContent = task.name;

      taskDependencyDropdown.appendChild(option);

      let firstTaskOption = document.createElement("option");
      firstTaskOption.value = task.name;
      firstTaskOption.textContent = task.name;

      firstTaskDropdown.appendChild(firstTaskOption);

      let endTaskOption = document.createElement("option");
      endTaskOption.value = task.name;
      endTaskOption.textContent = task.name;

      endTaskDropdown.appendChild(endTaskOption);
    });
  }

  // RENDER THE INPUT TASKS IN THE CONTAINER
  function renderTasks(tasks, containerId) {
    let taskContainer = document.getElementById(containerId);
    taskContainer.innerHTML = "";

    tasks.forEach(function (task) {
      let taskElement = document.createElement("div");
      taskElement.classList.add("task");

      let taskNameElement = document.createElement("span");
      taskNameElement.textContent = task.name;

      let taskDurationElement = document.createElement("span");
      taskDurationElement.textContent = task.duration;

      let taskDependencyElement = document.createElement("span");
      taskDependencyElement.textContent = task.dependency;

      // edit
      let editButton = document.createElement("button");
      editButton.textContent = "Edit";
      editButton.addEventListener("click", function () {});

      // delete
      let deleteButton = document.createElement("button");
      deleteButton.textContent = "Delete";
      deleteButton.addEventListener("click", function () {});

      taskElement.appendChild(taskNameElement);
      taskElement.appendChild(taskDurationElement);
      taskElement.appendChild(taskDependencyElement);
      taskElement.appendChild(editButton);
      taskElement.appendChild(deleteButton);

      taskContainer.appendChild(taskElement);
    });
  }

  // IMPLEMENTING DIJKSTRA
  class PriorityQueue {
    constructor() {
      this.elements = [];
    }

    enqueue(element, priority) {
      this.elements.push({ element, priority });
      this.elements.sort((a, b) => a.priority - b.priority);
    }

    dequeue() {
      return this.elements.shift().element;
    }

    isEmpty() {
      return this.elements.length === 0;
    }
  }

  class Graph {
    constructor() {
      this.vertices = {};
    }

    addVertex(vertex) {
      this.vertices[vertex] = {};
    }

    addEdge(source, destination, weight) {
      this.vertices[source][destination] = weight;
      this.vertices[destination][source] = weight;
    }

    dijkstra(startVertex) {
      const distances = {};
      const previous = {};
      const queue = new PriorityQueue();

      for (let vertex in this.vertices) {
        if (vertex === startVertex) {
          distances[vertex] = 0;
          queue.enqueue(vertex, 0);
        } else {
          distances[vertex] = Infinity;
          queue.enqueue(vertex, Infinity);
        }
        previous[vertex] = null;
      }

      while (!queue.isEmpty()) {
        const currentVertex = queue.dequeue();

        for (let neighbor in this.vertices[currentVertex]) {
          const distance =
                  distances[currentVertex] +
                  this.vertices[currentVertex][neighbor];

          if (distance < distances[neighbor]) {
            distances[neighbor] = distance;
            previous[neighbor] = currentVertex;
            queue.enqueue(neighbor, distance);
          }
        }
      }

      return { distances, previous };
    }

    getPath(previous, endVertex) {
      const path = [];
      let currentVertex = endVertex;

      while (currentVertex !== null) {
        path.unshift(currentVertex);
        currentVertex = previous[currentVertex];
      }

      return path;
    }
  }

  // SORT TASKS
  function updateTotalDuration(duration) {
    const totalDurationElement = document.getElementById("totalDuration");
    totalDurationElement.textContent = duration;
  }

  function sortTasks() {
    const graph = new Graph();

    tasks.forEach((task) => {
      graph.addVertex(task.name);
    });

    tasks.forEach((task) => {
      if (task.dependency !== "") {
        const weight = getDuration(task.dependency);
        graph.addEdge(task.name, task.dependency, weight);
      }
    });

    function getDuration(taskName) {
      const foundTask = tasks.find((task) => task.name === taskName);
      return foundTask ? parseInt(foundTask.duration) : 0;
    }

    let startTask = document.getElementById("firstTask").value;
    let endTask = document.getElementById("endTask").value;

    const { distances, previous } = graph.dijkstra(startTask);
    const shortestPath = graph.getPath(previous, endTask);

    let totalDuration = 0;
    shortestPath.forEach((task) => {
      totalDuration += getDuration(task);
    });

    console.log("Distances:", distances);
    renderShortestPath(shortestPath, "sortedTasksContainer");
    updateTotalDuration(totalDuration);

    // Calculate the sum of edge values
    let totalEdgeValue = 0;
    shortestPath.forEach((task, index) => {
      if (index > 0) {
        const weight = graph.vertices[task][shortestPath[index - 1]];
        totalEdgeValue += weight;
      }
    });
    console.log("Total Edge Value:", totalEdgeValue);
  }



  // RENDER THE SHORTEST PATH TASKS IN THE CONTAINER
  function renderShortestPath(shortestPath, containerId) {
    let sortedTasksContainer = document.getElementById(containerId);
    sortedTasksContainer.innerHTML = "";

    shortestPath.forEach(function (task) {
      let taskElement = document.createElement("div");
      taskElement.classList.add("task");

      let taskNameElement = document.createElement("span");
      taskNameElement.textContent = task;

      taskElement.appendChild(taskNameElement);

      sortedTasksContainer.appendChild(taskElement);

      // Output the task in the console
      console.log(task);
    });
  }
        </script>
    </body>
</html>
